함수형 인터페이스(Functional Interface)
		인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.
		이 때 @functionalInterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언하도록 제한한다.

람다식(Lambda Expression)
		함수형 인터페이스에서는 한 개의 추상 메소드만 존재하기 때문에 구현 시 메소드 이름이 딱히 필요가 없다.
		람다식은 이름이 없는 메소드로서, 값처럼 사용이 가능하고 당연히 매개변수로도 전달이 가능하다.
		따라서 람다식을 익명 메소드(Anonymous Method)라고도 부른다.

람다식 문법
		리턴타입 메소드명 (자료형 (3)매개변수명, ...) {실행할 문장; return 리턴 값;}
		1. (매개변수 형식 나열, ...) -> 리턴값;
		2. (매개변수 형식 나열, ...) -> {실행할 문장; return 리턴값;}
		3. 매개변수 -> 리턴값;
		4. 매개변수 -> {실행할 문장; return 리턴값;}

		//매개변수 하나라도 소괄호를 쓰는 것이 좋다. 왜? 가독성 때문에. 그냥 다 붙여서 써주면 될 것 같다.
		매개변수가 아예 없으면 () 소괄호 무조건 써야 한다.

[기초 실습]//이거 모르면 절대 안됨.
		package는 lambdaTask로 선언한다.
		
		PrintName 인터페이스 선언
		getFullName() 추상 메소드 선언
		- 성과 이름을 전달 받는다.

		PrintNameTest 클래스 선언
		printFullName() 메소드 선언
		- 외부에서 구현된 PrintName을 전달 받은 뒤 전체 이름을 출력

		main 메소드에서 printFullkName()을 사용하여 테스트 진행

[심화 실습]
여러 개의 정수를 입력받아서 알맞는 덧셈, 뺄셈 결과를 확인하는 애플리케이션 제작

입력 예1) 7 + 35 - 9
출력 예1) 33

입력 예2) -9 + 8 + 10
출력 예2) 9

* "ABC".split("")은 [A][B][C] 3칸 문자열 배열로 리턴된다.
   "A,B,C".split(",")은 [A][B][C] 3칸 문자열 배열로 리턴된다.
   split("구분점")을 전달하면 문자열에서 동일한 구분점을 기준으로 문자열 값을 잘라낸 후 문자열 배열로 리턴한다.
   구분점을 여러 개 사용할 때에는 split("구분점|구분점")으로 사용하며, "+", "-"를 구분점으로 사용할 때에는 "\\+", "\\-"로 표현한다.
   예)"4 + 9".split("\\+")은 [4][9] 2칸 문자열 배열로 리턴

* 사용자가 정상적으로만 입력한다는 가정 하에 구현하도록 한다.
* 두 정수를 전달받은 후 int로 리턴하는 calc 추상메소드 선언(함수형 인터페이스 제작) - Calc
* 두 정수의 덧셈, 뺄셈을 구해주는 함수형 인터페이스를 리턴하는 static 메소드 선언(람다식 리턴)
* 전체 식을 전달받은 후 String[]로 리턴하는 getOpers 추상메소드 선언(함수형 인터페이스 제작) - OperCheck
* main메소드에 getOpers를 람다식으로 구현 - MyMath(메인 메소드 선언)
* 첫번째 정수가 음수일 경우 오류 해결


//지금 같은 경우는 람다로 구현할 거니깐 펑셔널를 붙여준 것입니다.

=================================================================
예외 처리 //신입사원분들이 예외 처리를 아는데 어떻게 사용하는지 모름. 예외 처리 공부는 Spring을 예습한다고 생각하고 배우기
		컴파일 시, 빌드 시, 런타임 시 오류가 발생하면
		제어문으로 막을 수 없는 경우가 생긴다.
		이 때 예외 처리 문법을 해결할 수 있다.
		컴퓨터에 이상이 생길 정도로 심각한 오류는 에러라고 표현하고
		프로그램에 이상이 생긴 것을 예외라고 부른다.
		하지만 정해진 용어는 정확히 없으면, 보통 "오류"라고 부른다.

//컴파일 시, 빌드 시, 런타임 시 -> 이 말이 중요한 것.

예외 처리 문법
		try {
				오류가 발생할 수 있는 문장;
		}
   		catch (예외이름 객체명) {
    			  오류 발생 시 실행할 문장;
  		 }
  		 catch (예외이름 객체명) {
     			 오류 발생 시 실행할 문장;
  		 }
  		 ...

		finally {
				carch에서 잡히지 않은 오류가 있더라도 무조건 실행
		}


2시 ~ 2시 15분 다시 듣기

//
??

디버그

컴파일

빌드

링크

런타임 
//

알트 쉬프트 z - try catch 첫번째에 있음 - 엔터



예외 발생
		직접 예외를 발생시키기 위해서는 예외 던지기를 사용해야 하며, 이 때 생성자 호출 전 throw 키워드를 사용한다.
		예) throw new BadWordExceprion();

사용자 정의 예외
		기본적으로 제공되는 예외가 아닌 특정 상황에서 직접 예외를 만들어야 한다면,
		Exception 혹은 RunTimeException을 상속받아서 예외 클래스를 선언해야 한다.
		Exception은 컴파일가 체크하기 때문에 예외처리를 강제로 해야 하고,
		RuntimeException은 컴파일러가 체크하지 않기 때문에 예외처리를 선택할 수 있다.




내일 API 배움. 준비물: 핸드폰
//문자만 배우지않고, '메일'도 배울 것이라고 함.

object 배울 때 '상속'도 배움. // 제어문 꼭 열심히 공부하자!




















































































